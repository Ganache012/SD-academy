---
title: "실습"
output: html_notebook
---

```{R}
library(ggplot2)
```

# R에서 확률분포
- R에서 지원하는 분포 함수들이 있는데
- 정규분포(norm()), 이항분포(binom)

> d-: 확률밀도함수(확률질량함수)
> q-: 분위수
> p-: 누적분포함수
> r-: 표본추출

## 이항분포
```{R}
# dbinom(x, size, prob)
dbinom(2, size=6, prob=1/6)
```

- 주사위를 6번 던졌을 때, 1이 나오는 횟수를 x라고 한다면,
- X ~ B(6, 1/6) 이다.
- 주사위를 6번 던졌을 때, 1이 2번 나올 확률
- B(6, 1/6)의 x=2에서의 확률밀도함수값이다.

### 확률질량함수
```{R}
x <- 0.6
fx <- dbinom(x, 6, 1/6)
data=data.frame(x=x, pdf=fx)
ggplot(data=data, aes(x=x, y=pdf)) +
  geom_bar(stat='identity')
```

```{R}
demo <- tribble(
  ~cut, ~freq,
  "Fair", 1610,
  "Good", 4906,
  "Very Good", 12082,
  "Premium", 13791,
  "Ideal", 21551
)
```

```{R}
ggplot(data=demo) +
  geom_bar(mapping = aes(x=cut, y=freq), stat="identity")

```


## 표본추출함수
- 몬테카를로 시뮬레이션에서 난수를 생성해 계산을 근사적으로 실시
- R에서는 'r-'로 시작하는 함수를 이용해 난수를 생성
- 예를 들면, 주사위를 100번 던져서 1이 몇번 정도 나오는지를 확인해 볼 수 있다.
> 분포가 중요한 이유: 분포를 알고 있으면 표본을 임의로 만들어 낼 수 있다.
> 즉, 모집단을 알 수 있다는 것 바꿔 얘기하면 모집단의 분포를 알고 있다면,
> 그런데 모집을 알 수 없으니, 잘 알려진 분포라고 가정하고 분석을 수행
- 주사위의 분포는 이항분포에서 표본을 추출하는 것과같다.

```{R}
rbinom(100, size=1, prob=1/6)
```

- R에서 이항분포의 표본추출은 rbinom을 이용
- 100회의 베르누이 시행을 이용해 주사위를 100번 던졌을 경우 1이 나온 경우를 확인


```{R}
set.seed(1)
rbinom(1, size=100, prob=1/6)
```


# 정규분포
```{R}
dnorm(0, mean=0, sd=1)
```
```{R}
x= seq(-3, 3, length=1000)
fx = dnorm(x, mean=0, sd=1)
data = data.frame(x=x, pdf=fx)
ggplot(data= data, aes(x=x, y=pdf)) +
  geom_line()
```

```{R}
x= seq(-3, 3, length=1000)
fx = dnorm(x, mean=0, sd=2)
data = data.frame(x=x, pdf=fx)
ggplot(data= data, aes(x=x, y=pdf)) +
  geom_line()
```

- 데이터 만들기
```{R}
x = seq(-5, 5, length=1000)
fx1 = dnorm(x, mean=0, sd=1)
fx2 = dnorm(x, mean=0, sd=2)

normdata <- data.frame(x=x, norm1=fx1, norm2=fx2)
norm <- melt(normdata, measure.vars=c('norm1',  'norm2'))

ggplot(data=norm, aes(x=x, y=value, color=variable)) +
  geom_line()
```

```{R}
rnorm(10, mean=0, sd=1)
```

- 표준정규분포로부터 10개의 샘플(표본)을 추출한 결과

```{R}
x <- rnorm(1000, mean=0, sd=1)
tmp <- seq(-4, 4, length=1000)
# density: 밀도함수
ggplot(data=data.frame(x=x), aes(x=x)) +
  geom_histogram(aes(y=..density..)) +
  geom_line(data=data.frame(x=tmp, y=dnorm(tmp, 0, 1)), aes(x=x, y=y), col='red')
```

- 정규분포로부터 1000개의 샘플을 추출
- 해당 샘플에 대해서 확률밀도함수와 히스토그램을 그려본 결과
- 모집단이 정규분포라면 샘플도 정규분포를 따른다.
- 정규분포만 가능

## 중심극한정리
- 표본의 크기가 충분히 크다면 표본 또한 정규분호에 근사하게 된다.

### 균등분포
- 가장 간단한 연속확률분포로, 연속형 확률변수 x가 특정 구간에 속할 확률이 모두 동일한 경우
- 배차간격이 10분인 버스를 기다릴 때, 걸리는 시간은 0 ~ 10분 사이에서 모두 동일한 정도일 것이라 생각한다.
- unif()

```{R}
n=3
m=200
x.mean <- numeric(m)

for (i in 1:m) {
  x<- runif(3, min=0, max=1) # 균등분포로부터 3개의 표본을 추출
  x.mean[i] = mean(x)
}
x.mean
```

- 균등분포에서 3개의 표본을 추출하고, 표본평균을 구하는 실험을 200회 반복
- 수집된(추출된, 관찰된) 샘플의 평균(표준평균)에 대해서 정규분포로 근사함을 확인할 것이다

```{R}
ggplot(data = data.frame(mean=x.mean), aes(x=mean)) +
  geom_histogram()
```
- 표본평군의 히스토그램
- 중심극한정리에 따르면 표본크기 n을 키우면 표본 평균의 분포가 정규분포가 될 것임을 보장

- 표본의 크기를: 10개, 100개 정도로 늘리고  표본평균의 분포를 히스토그램으로 확인하기
- 표본의 크기를 늘리는 것과, 관찰의 횟수를 늘리는 것

## 다른 분포들
- -binom: 베르누이 분포, 이항분포
- -pois: 포아송 분포
- -unif: 균등분포
- -beta: 베타분포
- -norm: 정규분포

## 포아송 분포
```{R}
sample <- rpois(1000, lambda=5)

ggplot(data=data.frame(sample=sample), aes(x=sample)) +
  geom_histogram()
```

# 몬테카를로 시뮬레이션
- MCMC
- 난수를 이용해 실시하는 모의 실험을 뜻한다.
- 중심극한정리와 대수의 법칙에 의해서 수렴성이 보장이 되고, 수렴속도를 계산할 수 있다.(수학적으로 증명)
- 마코브 체인와 함께 머신러닝 추정에서 유용하게 사용

## 몬테카를로 적분
- 몬테카를로 방법을 이용해서 적분을 근사적으로 계산
- 예를 들면 반지름 1이고 중심각이 90도인 부채꼴이 넓이 파이/4로 알려져 있다.

```{R}
b = 1
a = 0
n = 1000
g <- function(x){
  sqrt(1-x^2)
}
# simulation
sample <- runif(n, min=a, max=b) # 균등분포
(b-a) * sum(g(sample))/n
```

```{R}
pi / 4
```

```{R}
b = 1
a = 0
n = 1000
g <- function(x){
  sqrt(1-x^2)
}

maxIter = 1000

set.seed(1)
simuls <- numeric(maxIter)
for(i in 0:maxIter){
  sample <- runif(1000, min=0, max=1)
  simuls[i] <- (b-a) * sum(g(sample))/n
}

ggplot(data=data.frame(value=simuls), aes(x=value))+
  geom_histogram() +
  geom_vline(xintercept = pi / 4, col='red')
```

## 도박사의 파산
- 현실에서 발생하는 확률모형은 기존의 모형으로 나타낼 수 없는 경우가 많다
- 초기 자본이 n원이 있고, 승률이 p%인 사람이 도박을 하러 갔을 떄,
- 파산하려면 얼마나 오랜 시간이 걸릴까?

- 해결: 시뮬레이션을 통해 샘플을 추출하고, 이를 통해서 모집단의 분포를 추론
  - 초기 자산을 n과 p로 저장한다.
  - sample 함수를 통해서 게임을 모의로 진행하고, n에 각 게임의 결과를 반영
  - 이 과정을 n이 0이 될때까지 반복
  - 승률이 47%일 때, 파산까지 얼마나 걸리겠는가?
  
```{R}
n <- 10000
p <- 0.47
z <- n
i <- 1
m <- 1000
ruin <- numeric(m)

for(j in 1:m){
  i<- 1
    repeat {
    i = i + 1
    y = sample(c(100, -100), size=1, prob=c(p, 1-p))
    n = n + y
    z[i] = n
    if(n <= 0) break 
    }  
  ruin[j] = i
  n <- 10000
}

ggplot(data = data.frame(N=ruin), aes(x=N)) +
  geom_histogram()
```

```{R}
mean(ruin)
```

# 베르누이 분포
# x 가 가질 수 있는 값은 0 or 1되는 형태의 분포

```{R}
N = 100000
set.seed(1)

x1 = rbinom(N, size=1, prob=1/4)
mean(x1) # 평균
var(x1) # 표준편차
```

# 이항 분포
- 베르누이 시행을 여러번 한 것
```{R}
x2 = rbinom(N, size=20, prob=1/4)
mean(x2)
var(x2)
```

# 포아송
```{R}
x3 = rpois(N, lambda = 10)
mean(x3)
var(x3)
```

```{R}
x4 = rnorm(N, mean=1, sd=2^2)
mean(x4)
var(x4)
```

# 도박사 문제

```{R}
n <- 10000
p <- 0.47
z <- n
i <- 1
m <- 1000
N <- 10000
recM <- numeric(m)

for(j in 1:m){
  i<- 0
    repeat {
    i = i + 1
    y = sample(c(100, -100), size=1, prob=c(p, 1-p))
    n = n + y
    if(n <= 0 | (y != 100)) break 
    }  
  recM[j] = i
  n <- 10000
}
#평균
mean(recM)
# 분산
var(recM)
```